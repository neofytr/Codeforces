#include <bits/stdc++.h>

// For fast I/O
void fast_io() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    std::cout.tie(NULL);
}

int main() {
    fast_io(); // Enable fast I/O

    int n;
    std::cin >> n;

    // The problem asks whether a flea, starting at one hassock (let's assume hassock 0),
    // and after minute 'k' jumping 'k-1' hassocks clockwise, will visit all 'n' hassocks.
    //
    // Let P_curr be the current position of the flea. Initially, P_curr = 0.
    // After minute 1 (k=1): flea jumps (1-1) = 0 hassocks.
    //   P_curr = (0 + 0) % n = 0.
    // After minute 2 (k=2): flea jumps (2-1) = 1 hassock.
    //   P_curr = (0 + 1) % n = 1.
    // After minute 3 (k=3): flea jumps (3-1) = 2 hassocks.
    //   P_curr = (1 + 2) % n = 3 % n.
    // After minute 4 (k=4): flea jumps (4-1) = 3 hassocks.
    //   P_curr = ( (3 % n) + 3) % n = 6 % n.
    //
    // In general, after minute 'm', the jump length is 'm-1'.
    // The position after 'm' jumps (i.e., after 'm' minutes) will be the sum of previous jump lengths
    // modulo 'n'.
    // The sum of jump lengths is 0 + 1 + 2 + ... + (m-1), which is a triangular number T_{m-1} = (m-1)*m / 2.
    // So, the sequence of positions visited (including the start) is:
    // P_0 = 0 (initial position)
    // P_1 = 0 (after 1 minute, T_0)
    // P_2 = 1 (after 2 minutes, T_1)
    // P_3 = 3 (after 3 minutes, T_2)
    // P_4 = 6 (after 4 minutes, T_3)
    // ...
    // P_m = (m-1)*m / 2 % n.
    //
    // This problem boils down to a known mathematical property:
    // The set of triangular numbers { T_i = i*(i+1)/2 } modulo 'n' visits all residues from 0 to n-1
    // if and only if 'n' is a power of 2.
    // Our sequence of positions is effectively T_0, T_1, T_2, ... where T_i = i*(i+1)/2.
    // Or, more accurately, the sequence is (0*(-1)/2), (1*0/2), (2*1/2), (3*2/2), ... which is also
    // the sequence of triangular numbers, just possibly offset in index.
    // The important thing is that the *set* of values generated by `i*(i-1)/2 % n` is the same as
    // the set of values generated by `i*(i+1)/2 % n`.
    // So, the condition for visiting all hassocks is that 'n' must be a power of 2.
    //
    // A positive integer 'n' is a power of 2 if and only if (n > 0) and (n & (n - 1)) == 0.
    // The problem constraint states 1 <= n <= 1000, so n is always positive.
    
    if ((n & (n - 1)) == 0) {
        std::cout << "YES\n";
    } else {
        std::cout << "NO\n";
    }

    return 0;
}