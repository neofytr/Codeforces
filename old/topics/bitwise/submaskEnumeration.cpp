#include <bits/stdc++.h>
using namespace std;

void printBinary(uint32_t number)
{
    for (int index = 31; index >= 0; index--)
    {
        if (number & (1 << index))
        {
            cout << 1;
        }
        else
        {
            cout << 0;
        }
    }
    cout << endl;
}

int main()
{
    // Enumerating all submasks of a given mask `m`
    // A submask `s` of `m` is a bitmask where all set bits of `s` are also set in `m`
    // i.e., s is a submask of m if and only if (s & m) == s

    uint32_t m = 0b010101; // example mask with k = 3 set bits
    uint32_t s = m;

    /*
        We prove that the following loop:
        1. Visits all submasks s of m, where s > 0
        2. Visits each submask exactly once
        3. Visits them in descending order
        4. Terminates after finitely many steps
    */

    while (s)
    {
        printBinary(s);

        // Update to next submask
        s = (s - 1) & m;
    }

    /*
    == FORMAL PROOF ==

    Let `S = { s | 0 < s <= m and (s & m) == s }` be the set of all non-zero submasks of m.
    Let popcount(m) = k, so |S| = 2^k - 1

    == Loop Invariant ==
    At the beginning of each iteration, `s` is a valid submask of `m`, i.e., (s & m) == s,
    and all values of `s` encountered are strictly decreasing and unique.

    == Base Case ==
    Initially, s = m
    - (m & m) == m, so m is a valid submask
    - m is the largest submask of itself
    => loop invariant holds

    == Inductive Step ==
    Suppose `s` is a valid submask at the start of some iteration
    Let s' = (s - 1) & m
    We claim:
    1. s' <= s - 1 < s, so values are strictly decreasing
    2. (s' & m) == s', since we AND with m => s' is also a submask
    3. s' is not equal to any previous submask (values strictly decrease, no repetition)
    => loop invariant holds for next iteration

    == Termination ==
    The sequence of `s` is strictly decreasing and bounded below by 0
    When s == 0, the loop terminates (s > 0 is false)
    - There are only 2^k - 1 positive submasks
    - Thus loop runs exactly 2^k - 1 iterations

    == Completeness ==
    Every s generated by (s - 1) & m is a submask of m
    All such s are unique and visited in descending order
    All non-zero submasks of m are visited

    == Time Complexity ==
    Let k = popcount(m), i.e., number of set bits in m
    - Total submasks of m = 2^k
    - We visit all submasks except 0 => 2^k - 1 iterations
    - Each iteration is O(1)

    => Total Time: O(2^k)
    */
}
