1. In questions that have the count of somethings changing when an operation is done and the total number of somethings remain constant, check how the parity of the count of things changes after an operation

2. In questions in which we can perform any operation from a group of operations, one after other, there is usually an optimal order for the
application of these operations (i.e., something like all operation 1s must occur before any operation 2s and so on) (see random/gettingZero)

3. For any x > 1, __builtin_ctzll(x) is the power of 2 in the prime factorization of x

4. If n is odd and >= 3, then
n, n - 1 and n - 2 have no prime
factors in common and
LCM(n, n - 1, n - 2) = n * (n - 1) * (n - 2)

5. For n >= 2, gcd(n, n - 1) = 1

6. Let x >= 1
Then, there can be atmost 1 number in the sequence

x, x + 1, x + 2, ..., x + (r - 1)

for some r >= 1 that is divisible by a number >= r

7. Count/Find triplets 1 <= i < j < k <= n that satisfy some conditions in O(n^2)

for (int k = 2; k <= n - 1; k++) {
	// iterate through [1, k - 1] to choose a suitable i

	// iterate through [k + 1, n] to choose a suitable j

	// check if (i, j, k) is a suitable pair
}

Thus, if we have to find a triplet, fix the middle one and solve two independent problems (if possible)

8. Let n >= 2
Let a1, a2, ..., an is a sequence of integers

If a1 <= an, then there are
two consecutive elements x, y
of the sequence such that x <= y

9. Let p(x1, y1) and q(x2, y2) be two points on a line y = mx + c.

Then, distance(p, q) = |x2 - x1| * root(1 + m * m)

For any integral m != 0, distance(p, q) is always irrational

10. For two distinct points P and Q in a plane to not have integral distance between them, it's necessary for them to be have different rows or different columns

11. For constructive questions, say we have to construct the maximal set satisfying some conditions, we can adopt the following approach:

i. Get an upper bound on the size of the set
ii. Do something to construct a set of that size

12. For x >= 0

i. floor(x / 2) = x >> 1
ii. ceil(x / 2) = (x >> 1) + (x & 1)

13. 

Consider a sorted array v[1, n]

Let f(r) = |r - v[1]| + |r + 1 - v[2]| + ... |r + n - 1 - v[n]|

         = |v[1] - (r + 0)| + ... + |v[n] - (r + (n - 1))|

We can calculate this in O(log(n)) with O(n) precomputation as follows:

1. Construct an array s[1, n] such that

s[i] = v[i] - (i - 1) for 1 <= i <= n

3. Construct the prefix array of s, say p[0, n]

p[0] = 0 and p[r] = p[r - 1] + s[r] for 1 <= r <= n

2. Find the first index k in the array v[1, n] such that v[k] >= r

If such a k does not exist, then
f(r) = r * n - p[n]

If k == 1, then f(r) = p[n] - r * n

Otherwise,

f(r) = (p[n] - p[k - 1]) - r * (n - k + 1) + r * (k - 1) - (p[k - 1])

14. 

Let n >= 1
Let S = {1, 2, ..., n}
Let A = {r is a natural number such that 1 <= r <= n * (n + 1) / 2}

Then, for any a in A, there is a subset s of S such that sum(s) = a
Also, there is no subset s of S such that
sum(s) > n * (n + 1) / 2

15.

Let n >= 3
Let l1, l2, ... , ln be positive integers

A polygon with n sides can be formed with
these integers as its side lengths iff

2 * max(l1, l2, ..., ln) <= l1 + l2 + ... + ln

, i.e, no side-length is greater than all the other side-lengths combined

16. In a problem where we are to count
the number of pairs of indexes (i, j) where 1 <= i < j <= n in an array arr[1, n] satisfying some condition, we can permute (usually, the permutation of the array used is the sorted one) the array beforehand and solve the problem if

i. Condition depends on values, not positions
ii. The number of pairs is invariant under the permutation
iii. Counting pairs/combinations/subsets
iv. Answer is unchanged by reordering (permutation invariant)

We cannot permute the array if

i. Problem involves subarrays/prefixes/suffixes
ii. Ordering of the elements matters
iii. Distance/position constraints are essential

16. 

Let k >= 0

Let A[1, n] and B[1, m] be two integer arrays such that

0 <= A[r] < 2^k for 1 <= r <= n

Let f[s] = Summation from r = 1 to n of (A[r] ^ B[s]) for 1 <= s <= m

Suppose we want to find max(f[s] for 1 <= s <= m) in O(n + m)

We can do this as follows:

vector<int> bit(k);
for (int r = 1; r <= n; r++)
	for (int b = 0; b <= k - 1; b++)
		if (A[r] & (1 << b)) bit[b]++;

// We can now calculate each f[s] for 1 <= s <= m in O(1) now after this precomputation that is done in O(n)

int maxi = LLONG_MIN;
for (int r = 1; r <= m; r++) {
	int sum = 0;
	for (int b = 0; b <= k - 1; b++)
		if (B[r] & (1 << b)) sum += bit[b] * (1 << b);
		else sum += (n - bit[b]) * (1 << b)
}

17. 

Let x >= 1
Let z is the smallest power of two >= x

Then x ^ y, for y >= 1 and y != x, divides y implies that y <= z - 1

18. 

Let A[1, n] and B[1, k] are sorted
array of integers

Let f: A -> B 

Suppose we are to find an assignment f such that

1. summation |A[r] - B[f[r]]| for 1 <= r <= n is minimized

or

2. max(|A[r] - B[f[r]]| for 1 <= r <= n) is minimized

Then, it is not optimal to assign in a crossed manner, i.e, 

If we assign B[j] to some A[r], then, it is not optimal to assign A[r + 1] to any B[s] for s < j

19. Chicken McNugget Theorem

If you have two positive integers a and b that are coprime (that is, gcd(a, b) = 1), then, the largest
integer that cannot be written in the form ax + by, where x and y are non-negative integers, is ab - a - b
After this number, every larger number is representable

20.

Let f(x) = 11...1 (total of x ones)
Then, for any x >= 2, f(x) = 11 * a + 111 * b for some non-negative integers a and b

Rough Proof:

There are three possible cases for x:

1. x = 3 * r for some r >= 1
Then f(x) = 111 * pw(10, x - 3) + 111 * pw(10, x - 6) ... + 111 * pw(10, 0) = 111 * y for some y >= 0

2. x = 3 * r + 1 = 3 * (r - 1) + 4 for r >= 2
Then f(x) = 111 * pw(10, x - 3) + .. + 111 * pw(10, 4) + 11 * 100 + 11 = 111 * a + 11 * b for some a, b >= 0

3. x = 3 * r + 2
Then f(x) = 111 * pw(10, x - 3) + ... + 111 * pw(10, 2) + 11 * 100 = 111 * a + 11 * b for some a, b >= 0

21.

Let n >= 2
Let arr[1, n] be an array of non-negative integers

Suppose we have to partition arr into consecutive subarrays such that the XOR of all the subarrays are equal.
A partition with 1 subarray is always possible (the trivial partition {{1, 2, ..., n}})

Suppose we need to have the number of partitions >= 2
Let p[0] = 0 and p[r] = p[r - 1] ^ arr[r] for 1 <= r <= n

If p[n] = 0, then we can always partition arr[1, n] into two subarrays with equal XORs ->
{{1, ..., r}, {r + 1, ..., n}} where the XORs of both the subarrays are equal
Such two subarrays always exist since if the XOR of some numbers is 0, then its possible iff the numbers are equal
And since p[n] = arr[1] ^ ... ^ arr[n] = 0, then we will always have p[n] = x ^ x where the first x is the xor of some prefix, and the
second x is xor of the rest of the array

If p[n] > 0, then, no even length partition exists since XOR of an equal number of even things is zero
So if the array can be partitioned, it will have an odd length partition
Now, since the XORs of the partitioned subarrays are equal and the partitioned subarrays are odd in number,
the XORs of these partitioned subarrays = p[n]
So, we can check if such a partition exists by the following code:

int cnt = 0, l = 1, r = 1;
while (l <= r) {
    l = r;
    while (r <= n && (p[r] ^ p[l - 1] != p[n]) r++;
    if (r <= n && p[r] ^ p[l - 1] == p[n]) cnt++;
    l = r + 1;
}

if (cnt >= 1) return true;
else return false;

22.

When during thinking of a transition for dp[r], you find that the transition involves dependency
on values of some dp[r + l] where l > 0, then, think of push-dp or recursion to solve the problem.

23. String DP Patterns

Four things to remember:

The "prefix to prefix" pattern (comparing beginnings of both strings) is the foundation of all string DP.

1. String DP compares prefixes. dp[i][j] relates prefix of string A to prefix of string B
2. Match v/s operate. When characters match, you get a free transition.
3. Three choices become one min. Replace, delete, insert map to three neighbors.
4. Base cases are edge strings. Empty-to-something costs the length.

For example consider the problem Edit Distance.
Let A[1, n] and B[1, m] be the two strings

We define dp[i][j] is the minimum number of operations required to convert A[1, i] into B[1, j]
Here are the transitions

dp[0][0] = 0
dp[0][j] = j for all 1 <= j <= m
dp[i][0] = i for all 1 <= i <= n

dp[i][j] = dp[i - 1][j - 1] if A[i] = B[j]
         = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1) otherwise

The final answer is dp[n][m]